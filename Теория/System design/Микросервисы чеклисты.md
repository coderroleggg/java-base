# Чеклисты по микросервисам

## Когда пора разбивать монолит

### 1. Проблемы с командой
- [ ] 10+ разработчиков работают над одной кодовой базой
- [ ] Конфликты при мерже случаются каждый день
- [ ] Разные команды часто блокируют друг друга
- [ ] Code review занимает больше 2 дней
- [ ] Онбординг новых разработчиков занимает >2 недель
- [ ] Сложно определить владельцев компонентов
- [ ] Разные команды имеют разные приоритеты и скорость релизов

### 2. Технические индикаторы
- [ ] Время сборки проекта >10 минут
- [ ] Деплой занимает >30 минут
- [ ] Откат изменений сложно сделать быстро
- [ ] Тесты выполняются >20 минут
- [ ] Частые OutOfMemoryError в проде
- [ ] CI пайплайн падает несколько раз в день
- [ ] Сложно изолировать и тестировать компоненты
- [ ] Высокая связность между модулями

### 3. Бизнес-триггеры
- [ ] Разные части системы требуют разного SLA
- [ ] Есть компоненты с разными пиками нагрузки
- [ ] Некоторые функции нужно обновлять чаще других
- [ ] Бизнес требует быстрых изменений
- [ ] Разные требования по безопасности к разным частям
- [ ] Разные компоненты масштабируются по-разному
- [ ] Четко выделены бизнес-домены с разной логикой

### 4. Архитектурные признаки
- [ ] Явно выделяются независимые бизнес-домены
- [ ] Много несвязанных бизнес-процессов
- [ ] Разные части требуют разных технологий
- [ ] Есть четкие границы между компонентами
- [ ] Много асинхронных процессов
- [ ] Можно выделить автономные компоненты
- [ ] Низкая связность между доменами

### 5. Инфраструктурная готовность
- [ ] Есть опыт с Docker/Kubernetes
- [ ] Настроен мониторинг
- [ ] Есть DevOps инженеры
- [ ] Автоматизирован деплой
- [ ] Есть бюджет на дополнительные серверы
- [ ] Настроено логирование
- [ ] Есть опыт работы с распределенными системами

## Критерии для выделения отдельного микросервиса

### 1. Бизнес-критерии
- [ ] Решает одну бизнес-задачу
- [ ] Имеет свой набор бизнес-правил
- [ ] Может работать автономно
- [ ] Имеет четкие границы ответственности
- [ ] Не дублирует логику других сервисов
- [ ] Имеет понятный бизнес-контекст
- [ ] Соответствует организационной структуре

### 2. Данные
- [ ] Может иметь свою БД
- [ ] Минимум связей с другими сервисами
- [ ] Владеет своими данными
- [ ] Не требует частых распределенных транзакций
- [ ] Имеет понятную модель данных
- [ ] Данные логически связаны
- [ ] Редко нужна синхронизация с другими сервисами

### 3. Технические аспекты
- [ ] Может масштабироваться независимо
- [ ] Имеет четкий API
- [ ] Не создает циклических зависимостей
- [ ] Имеет управляемый размер кодовой базы
- [ ] Легко тестируется изолированно
- [ ] Имеет минимум внешних зависимостей
- [ ] Использует подходящий стек технологий

### 4. Операционные критерии
- [ ] Может быть развернут независимо
- [ ] Имеет свои метрики и логи
- [ ] Может быть откачен отдельно
- [ ] Имеет свой CI/CD пайплайн
- [ ] Не ломает систему при падении
- [ ] Имеет стратегию отката изменений
- [ ] Мониторится независимо

### 5. Команда
- [ ] Может обслуживаться одной командой
- [ ] Размер кода позволяет легко разобраться
- [ ] Понятная документация
- [ ] Определены владельцы
- [ ] Есть специфическая экспертиза
- [ ] Команда автономна
- [ ] Понятная зона ответственности

## Красные флаги

### Сервис НЕ должен быть отдельным если:
- [ ] Часто меняется вместе с другими сервисами
- [ ] Требует синхронных вызовов в цепочке
- [ ] Сложно тестировать изолированно
- [ ] Много дублирования с другими сервисами
- [ ] Нет четких границ ответственности
- [ ] Сильно связан с другими сервисами
- [ ] Требует сложной оркестрации
- [ ] Часто участвует в распределенных транзакциях
- [ ] Имеет нечеткий бизнес-домен
- [ ] Слишком мал для отдельного сервиса
- [ ] Требует доступа к данным многих других сервисов

## Примеры

### Хороший кандидат на выделение:
```java
@Service
public class PaymentService {
    // Четкая бизнес-логика
    public PaymentResult processPayment(PaymentRequest request) {
        // Независимая обработка платежа
        // Минимум внешних вызовов
        // Четкие границы ответственности
    }
}
```

### Плохой кандидат:
```java
@Service
public class UserOrderService {
    // Смешанная логика
    public Order createOrderForUser(Long userId, OrderRequest request) {
        User user = userClient.getUser(userId);
        PaymentInfo payment = paymentClient.getPaymentInfo(userId);
        // Много внешних зависимостей
        // Нечеткие границы
    }
}
```

## Правила принятия решения

1. Начинай с монолита
2. Выделяй очевидные кандидаты первыми
3. Следуй бизнес-доменам
4. Учитывай организационную структуру
5. Оценивай операционные затраты
6. Планируй инкрементальное разделение
7. Документируй причины решений

## Полезные метрики для принятия решения

1. Частота изменений
2. Количество зависимостей
3. Объем кодовой базы
4. Количество распределенных транзакций
5. Частота деплоев
6. Требования к масштабированию
7. Размер команды
8. Сложность тестирования

## Заключение

Используй эти чеклисты как руководство, но не как догму. Каждый проект уникален и может требовать собственных критериев оценки. Главное - чтобы разделение решало реальные проблемы, а не создавало новые :)